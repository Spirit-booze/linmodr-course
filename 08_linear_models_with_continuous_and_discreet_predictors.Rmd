---
title: "Линейные модели с непрерывными и дискретными предикторами"
subtitle: Линейные модели, дисперсионный и регрессионный анализ с использованием R, осень 2015
author: Марина Варфоломеева, Вадим Хайтов
presenters: [{
    name: 'Марина Варфоломеева',
    company: 'каф. ЗБП, СПбГУ',
    }]
output:
  ioslides_presentation:
    widescreen: true
    css: my_styles.css
    logo: Linmod_logo.png
---

```{r setup, include = FALSE, cache = FALSE}
#-- RUN THE FRAGMENT BETWEEN LINES BEFORE COMPILING MARKDOWN
# to configure markdown parsing
options(markdown.extensions = c("no_intra_emphasis", "tables", "fenced_code", "autolink", "strikethrough", "lax_spacing", "space_headers", "latex_math"))
#------
# output options
options(width = 70, scipen = 6, digits = 3)

# to render cyrillics in plots use cairo pdf
options(device = function(file, width = 7, height = 7, ...) {
  cairo_pdf(tempfile(), width = width, height = height, ...)
  })
library(knitr)
# chunk default options
opts_chunk$set(fig.align='center', tidy = FALSE, fig.width = 7, fig.height = 3)
```

```{r libs-funs, echo=FALSE}
lm_equation <- function(fit, strict = TRUE, rnd = 2){
#   extracting call formula 
  frml <- as.character(fit$call)[2]
#   extract signs
    sign <- ifelse(grepl("-", coef(fit)[-1]), " - ", " + ")
  # extract coefficients
  coeffs <- format(round(abs(coef(fit)), rnd), digits = 2, trim = TRUE)
  if(strict == TRUE){
    i <- 1:(length(coeffs) - 1)
    vars <- c("Y", paste0(" X", i))
    
  } else {
# extract vector of variable names
  vars <- c(all.vars(formula(fit))[1], names(fit$coefficients)[-1])
# combine everything
  }
  start <- ifelse(coef(fit)[1] > 0, paste(vars[1], coeffs[1], sep = " = "), paste(vars[1], coeffs[1], sep = " = - "))
  end <- paste(sign, coeffs[-1], vars[-1], sep = "", collapse = "")
  return(cat(start, end, sep = ""))
}
```

## Мы рассмотрим

+ Линейные модели c непрерывными и дискретными предикторами
+ Простейший экспериментальный план, требующий анализа ковариации (ANCOVA)

### Вы сможете

+ Написать на языке R код, необходимый для подгонки линейной модели, включающей дискретные и непрерывные предикторы, а так же их взаимодействие
+ Дать трактовку коэффициентам такой линейной модели

## Пример: Клевер и тысячелистник

Тысячелистник _Achillea millefolium_ часто растет как сорняк на полях вместе с клевером _Trifolium repens_. Зависит ли урожай клевера от плотности тысячелистника?

```{r}
clover <- read.delim("data/clover.csv")
names(clover)
# Для удобства переименуем переменные
names(clover) <- c("Plot", "Clover", "Yarrow")
```

- Plot - участок (A, B, C)
- Clover - количество семян клевера (г/кв.м)
- Yarrow - плотность тысячелистника (число цветущих стеблей на кв.м)

<div class=.footnote>из кн. Saville, Wood, 1991</div>

## Посмотрим внимательно на данные

```{r}
nrow(clover)
# есть ли пропущенные значения?
any(is.na(clover))
# как закодирована переменная Plot?
class(clover$Plot) # это фактор
levels(clover$Plot) # уровни этого фактора
# # Если вы открывали xlsx файл при помощи read_excel, 
# # то фактор вам придется сделать самостоятельно
# clover$Plot <- factor(clover$Plot)
```

## Сколько площадок собрали с каждого из участков?

```{r}
table(clover$Plot)
```

## Построим график зависимости урожайности клевера от плотности тысячелистника

```{r}
library(ggplot2)
theme_set(theme_bw(base_size = 14)+ theme(legend.key = element_blank()))
gg_cl <- ggplot(data = clover, aes(y = Clover, x = Yarrow)) + 
  geom_point() +
  labs(x = "Плотность тысячелистника, цветоносов/кв.м",
       y = "Урожайность клевера, г/кв.м")
gg_cl + geom_smooth(method = "lm")
```

## Не зная про несколько участков, мы бы просто подобрали обычную линейную регрессию

```{r}
M1 <- lm(Clover ~ Yarrow, data = clover)
summary(M1)
```

## Запишем уравнение этой линейной регрессии

```{r}
coef(M1) #Коэффициенты модели
```

Уравнение:

```{r, echo=FALSE, results='asis'}
lm_equation(M1, strict = FALSE)
```

Трактовка коэффциентов:

- $b_0 =$ `r coef(M1)[1]` - интерсепт. Это урожайность клевера, если нет тысячелистника
- $b_1 =$ `r coef(M1)[2]` - угол наклона. Он показывает на столько уменьшается урожайность клевера при увеличении плотности тысячелистника на 1 цветонос на кв.м

## Но мы знаем, что было несколько участков

Хорошо бы проверить, различается ли между участками зависимость урожайности клевера от плотности тысячелистника.

```{r}
gg_cl + aes(colour = Plot) + labs(colour = "Участок")
```

## Дискретные предикторы тоже можно включать в линейные модели.

Кодируем дискретный предиктор (фактор) при помощи числовых переменных-болванок (dummy variables) и можем пользоваться регрессией

Переменных болванок нужно на одну меньше, чем число уровней фактора

Для каждого из объектов каждая из болванок принимает значение 1 для своего уровня фактора

## Пробуем вручную создавать переменные-болванки

R может все сделать автоматически, но давайте попробуем вручную создать переменные-болванки и сравнить результаты с автоматическим способом.

В примере с клевером понадобится 2 переменных болванки

```{r}
clover$Plot_B <- as.numeric(clover$Plot == "B")
clover$Plot_C <- as.numeric(clover$Plot == "C")
```

Почему нам не нужна отдельная переменная-болванка для участка A?

## Почему нам не нужна отдельная переменная-болванка для участка A? {.smaller}

Потому что, если площадка с участка А, то `Plot_B` и `Plot_C` будут равны 0
```{r dummies, eval=FALSE}
clover[, c("Plot", "Plot_B", "Plot_C")]
```

<div class="columns-2">
```{r dummies, echo=FALSE}
```
</div>

## Подбираем параметры линейной модели

```{r}
M2_dummy <- lm(Clover ~ Yarrow + Plot_B + Plot_C, data = clover)
```

### На самом деле, мы можем сразу подобрать нужную модель с дискретным предиктором. В ручном создании болванок нет необходимости.

```{r}
M2 <- lm(Clover ~ Yarrow + Plot, data = clover)
```

Значения коэффициентов получатся одинаковые

```{r}
coef(M2)
coef(M2_dummy)
```

## Смотрим на результаты линейной модели {.smaller}

### Внимание! Эта модель описывает три __параллельные линии__ для каждого из уровней фактора Участок, поскольку не включает взаимодействие факторов

```{r}
summary(M2)
```

## Попробуем записать уравнение модели, где появился дискретный предиктор {.smaller}

```{r}
coef(M2)
```

Уравнение:

```{r, echo=FALSE, results='asis'}
lm_equation(M2, strict = FALSE)
```

Трактовка коэффциентов:

- $b_0 =$ `r round(coef(M2)[1], 2)` - интерцепт, урожайность клевера __на базовом уровне (на участке A)__, если нет тысячелистника

Общий угол наклона:

- $b_1 =$ `r round(coef(M2)[2], 2)` - на столько уменьшается урожайность клевера на любом участке при увеличении плотности тысячелистника на 1 цветонос на кв.м

Поправки для интерцепта:

- $b_2 =$ `r round(coef(M2)[3], 2)` - отличие урожайности клевера __на участке B от участка A__
- $b_3 =$ `r round(coef(M2)[4], 2)` - отличие урожайности клевера __на участке C от участка A__

## Давайте запишем отдельные уравнения для каждого типа участков

Общее уравнение модели с параллельными линиями:

```{r, echo=FALSE, results='asis'}
lm_equation(M2, strict = FALSE, rnd = 3)
```

Для участка A:

Clover = 57.58 - 0.11 Yarrow

Для участка B:

Clover = (57.58 + 0.32) - 0.11 Yarrow = 57.9 - 0.11 Yarrow

Для участка C:

Clover = (57.58 - 0.54) - 0.11 Yarrow = 57.04 - 0.11 Yarrow

## Базовый уровень

Уровень дискретного предиктора, для записи которого мы не использовали отдельную переменную-болванку, называется базовым.

Интерцепт в уравнении регрессии описывает среднее значение предиктора на базовом уровне.

В R базовым уровнем считается первый уровень фактора

```{r}
levels(clover$Plot)
```

В данном случае это уровень "A"

## Что произойдет с моделью, если мы изменим базовый уровень? {.smaller}

```{r}
clover$Plot <- relevel(clover$Plot, ref = "C")
levels(clover$Plot) # Теперь первым идет "C"
```
```{r}
M2_C <- lm(Clover ~ Yarrow + Plot, data = clover)
summary(M2_C)
```

## Изменился ли смысл модели от смены уровней? Нет! {.smaller}

<div class="columns-2">
```{r, }
coef(M2)
```

```{r, echo=FALSE,results='asis'}
lm_equation(M2, strict = FALSE, rnd = 3)
```

Трактовка коэффциентов:  
- $b_0 =$ `r round(coef(M2)[1], 2)` - интерцепт, урожайность клевера __на базовом уровне (на участке A)__, если нет тысячелистника

Общий угол наклона:  
- $b_1 =$ `r round(coef(M2)[2], 2)` - на столько уменьшается урожайность клевера на любом участке при увеличении плотности тысячелистника на 1 цветонос на кв.м

Поправки для интерцепта:  
- $b_2 =$ `r round(coef(M2)[3], 2)` - отличие урожайности клевера __на участке B от участка A__
- $b_3 =$ `r round(coef(M2)[4], 2)` - отличие урожайности клевера __на участке C от участка A__

```{r}
coef(M2_C)
```

```{r, echo=FALSE,results='asis'}
lm_equation(M2_C, strict = FALSE, rnd = 3)
```

Трактовка коэффциентов:  
- $b_0 =$ `r round(coef(M2_C)[1], 2)` - интерцепт, урожайность клевера __на базовом уровне (на участке С)__, если нет тысячелистника

Общий угол наклона:  
- $b_1 =$ `r round(coef(M2_C)[2], 2)` - на столько уменьшается урожайность клевера на любом участке при увеличении плотности тысячелистника на 1 цветонос на кв.м

Поправки для интерцепта:  
- $b_2 =$ `r round(coef(M2_C)[3], 2)` - отличие урожайности клевера __на участке A от участка C__
- $b_3 =$ `r round(coef(M2_C)[4], 2)` - отличие урожайности клевера __на участке B от участка C__

</div>

## Изменился ли смысл модели от смены уровней? {.smaller}

### Даже уравнения для каждой из прямых остались прежними в пределах ошибки округления

<div class="columns-2">

Общее уравнение модели с параллельными линиями:

```{r, echo=FALSE, results='asis'}
lm_equation(M2, strict = FALSE, rnd = 3)
```

Для участка A:

Clover = 57.58 - 0.11 Yarrow</br></br>

Для участка B:

Clover = (57.58 + 0.32) - 0.11 Yarrow =  
= 57.9 - 0.11 Yarrow

Для участка C:

Clover = (57.58 - 0.54) - 0.11 Yarrow =  
= 57.04 - 0.11 Yarrow

Общее уравнение модели с параллельными линиями:

```{r, echo=FALSE, results='asis'}
lm_equation(M2_C, strict = FALSE, rnd = 3)
```

Для участка A:

Clover = (57.03 + 0.54) - 0.11 Yarrow =  
= 57.57 - 0.11 Yarrow

Для участка B:

Clover = (57.03 + 0.86) - 0.11 Yarrow =  
= 57.89 - 0.11 Yarrow

Для участка C:

Clover = 57.03 - 0.11 Yarrow

</div>

## График модели с одинаковыми углами наклона {.smaller}

Нужны исходные данные с предсказанными значениями и стандартными ошибками. При этом хорошо бы, чтобы диапазоны предикторов для каждого из уровней дискретной переменной соответствовали реальным значениям.

Решение средствами пакета `plyr`:
```{r, tidy=FALSE}
library(plyr)
# делим датафрейм на части по переменной Plot
# по каждой из частей считаем при помощи summarise
# последовательность от мин. до макс. значения Yarrow
my_df <- plyr::ddply(clover, .(Plot),
    summarise,
    Yarrow = seq(min(Yarrow),  max(Yarrow), length = 10))
# Считаем предсказанные значения и стандартные ошибки
M2_pred <- predict(M2, newdata = my_df, se.fit = TRUE)
# Добавляем их в датафрейм
my_df$Clover <- M2_pred$fit
my_df$SE <- M2_pred$se.fit
```

## Самостоятельно попробуйте разобрать, как сделать тот же самый исходный датафрейм в пакете dplyr

```{r, eval=FALSE, tidy=FALSE}
# Выгружаем plyr, потому что dplyr конфликтует с plyr
detach("package:plyr", unload=TRUE)
library(dplyr)
# Разбиваем clover на группы по переменной Plot 
# и считаем минимум и максимум Yarrow
minmax <- clover %>% group_by(Plot) %>%
  summarise(mYarrow = min(Yarrow),
  MYarrow = max(Yarrow))
# Pазбиваем minmax по переменной Plot создаем датафрейм, 
# где Yarrow - это последовательность от минимума до максимума для данного Plot,
# снимаем группировку,
# добавляем предсказанные значения и стандартные ошибки
my_df <- minmax %>% group_by(Plot) %>% 
  do(data.frame(Yarrow = seq(.$mYarrow, .$MYarrow, length = 10))) %>% 
  ungroup %>% 
  mutate(Clover = predict(M2, newdata = .),
    SE = predict(M2, newdata = ., se.fit = TRUE)$'se.fit')
```

## Строим график с параллельными прямыми

```{r, tidy=FALSE, fig.height=3}
gg_cl_parallel <- ggplot(data = my_df, aes(y = Clover, x = Yarrow, colour = Plot, fill = Plot)) + 
  geom_line() + 
  geom_ribbon(aes(ymax = Clover + 1.98 * SE, 
                  ymin = Clover - 1.98 * SE),
              alpha = 0.3, colour = NA) +
    geom_point(data = clover) +
  labs(colour = "Участок", fill = "Участок", 
       x = "Плотность тысячелистника, цветоносов/кв.м",
       y = "Урожайность клевера, г/кв.м")
gg_cl_parallel
```

## Добавим отдельные панели

```{r}
gg_cl_parallel + facet_wrap(~ Plot)
```

## Но может быть линии на самом деле не параллельны? {.smaller}

### Мы должны были начать с этой, полной, модели!!!

Чтобы проверить, одинаковы ли зависимости для каждого из участков, нам нужно подобрать модель со взаимодействием и протестировать его значимость.

```{r, R.options=list(width = 90)}
# вернем уровни на место в прежнем порядке
clover$Plot <- factor(clover$Plot, levels = c("A", "B", "C"), labels = c("A", "B", "C")) 
M3 <- lm(Clover ~ Yarrow * Plot, data = clover)
coef(M3)
```

Общее уравнение:  
```{r, echo=FALSE, results='asis'}
lm_equation(M3, strict = FALSE, rnd = 3)
```

Трактовка коэффциентов:  
- $b_0 =$ `r round(coef(M3)[1], 3)` - урожайность клевера, если нет тысячелистника (на участке A, а для других - с учетом поправки)  
- $b_1 =$ `r round(coef(M3)[2], 3)` - угол наклона прямой (для участка А, а для других - с учетом поправок)

<div class="columns-2">
Поправки интерсепта:  
- $b_2 =$ `r round(coef(M3)[3], 3)` - для участка B  
- $b_3 =$ `r round(coef(M3)[4], 3)` - для участка C

Поправки угла наклона:  
- $b_4 =$ `r round(coef(M3)[5], 3)` - для участка B  
- $b_5 =$ `r round(coef(M3)[6], 3)` - для участка C

</div>

## Чтобы лучше понять смысл коэффициентов, давайте запишем отдельные уравнения для каждого типа участков

Общее уравнение модели с разными углами наклона:

```{r, echo=FALSE, results='asis'}
lm_equation(M3, strict = FALSE, rnd = 3)
```

Для участка A:

Clover = 55.219 - 0.094 Yarrow

Для участка B:

Clover = (55.219 + 0.606) + (- 0.094 - 0.002) Yarrow = 55.825 - 0.096 Yarrow

Для участка C:

Clover = (55.219 + 8.081) + (- 0.094 - 0.054) Yarrow = 63.3 - 0.148 Yarrow

## График с разными углами наклона

```{r}
gg_cl + aes(colour = Plot, fill = Plot) + 
  geom_smooth(method = "lm", alpha = 0.2) +
  labs(colour = "Участок", fill = "Участок")
```

## Проверяем условия применимости

```{r, fig.show='hold', fig.height=3.5, fig.width=10}
library(car)
op <- par(mfrow = c(1, 3), cex = 1)
qqPlot(M3)
plot(M3, which = 3)
plot(M3, which = 4)
par(op)
```

Есть подозрение на гетерогенность дисперсий

## Проверим остатки на гетерогенность дисперсий тестом Бройша-Пагана

```{r, message=FALSE}
library(lmtest)
bptest(M3)
```

Все в порядке, можно продолжать

## Как проверить, действительно ли различается урожайность между участками?

### 1 способ:

При помощи частного F-критерия можно сравнить полную и уменьшенную модель

На первом этапе пробуем удалить только взаимодействие
```{r}
drop1(M3, test = "F")
```
При удалении взаимодействия модель не ухудшается. Взаимодействие можно не учитывать

## Как проверить, действительно ли различается урожайность между участками?

### 1 способ (продолжение):

Подбираем модель без взаимодействия. На самом деле, мы это уже делали. Это M2
```{r}
# M2 <- lm(Clover ~ Yarrow + Plot, data = clover)
drop1(M2, test = "F")
```
При удалении Plot модель не ухудшается - выкидываем Plot

## Как проверить, действительно ли различается урожайность между участками?

### 1 способ (продолжение):

Подбираем модель без Plot На самом деле, мы это уже делали. Это M1
```{r}
# M1 <- lm(Clover ~ Yarrow, data = clover)
drop1(M1, test = "F")
```

Из этой модели уже ничего не выкинуть

## Как проверить, действительно ли различается урожайность между участками?

### 2 способ:

Можно провести дисперсионный анализ одним из способов (подробнее в следующей лекции)
```{r}
# anova(M3)        # способ А
# summary(aov(M3)) # способ Б
library(car)     # способ В
Anova(M3)
```

## После подбора финальной модели нужно еще раз проверить условия применимости

```{r, fig.show='hold', fig.height=3.5, fig.width=10}
op <- par(mfrow = c(1, 3), cex = 1)
qqPlot(M1)
plot(M1, which = 3)
plot(M1, which = 4)
par(op)
```

Есть подозрение на гетерогенность дисперсий

## Проверим остатки на гетерогенность дисперсий тестом Бройша-Пагана

```{r, message=FALSE}
bptest(M1)
```

На грани. Если рассуждать формально, то можно продолжать.

Модель M1 - финальная
```{r}
coef(M1)
```

```{r, echo=FALSE, results='asis'}
lm_equation(M1, strict = FALSE, rnd = 3)
```

## Пример: Козы и глисты

Как влияет на прирост массы коз интенсивность профилактики паразитарных заболеваний?

Известно, что у легких животных привес больше, поэтому мы должны учитывать в модели не только способ обработки от глистов, но и влияние начального веса.

<div class="columns-2">

- Treatment - обработка от глистов (стандартная, интенсивная)
- Weightgain - привес, кг
- Initial.wt - начальный вес, кг

<img src="images/Goat-by-Jennifer-C.-Flickr.jpg" width="300" height="300">   
Goat by Jennifer C. [on Flickr](https://flic.kr/p/fjU4J9)
</div>

<div class=.footnote>Пример из библиотеки данных   
http://www.statlab.uni-heidelberg.de/data/ancova/goats.story.html</div>

## Читаем и знакомимся с данными

```{r}
goat <- read.delim("data/goats.csv")
str(goat)
# переименуем переменные для краткости
colnames(goat) <- c("treat", "wt", "init")
any(is.na(goat))
table(goat$treat)
```

## Проверим порядок уровней фактора
```{r}
levels(goat$treat)
```

Хорошо бы поменять их местами для удобства интерпретации

```{r}
goat$treat <- relevel(goat$treat, ref = "standard")
```

## Задание

1. Подберите модель, описывающую зависимость между увеличением веса коз и способом прфилактической обработки животных.
2. Проверьте условия применимости этой модели
3. Попробуйте сократить модель, чтобы она стала оптимальной.
4. Проверьте условия применимости финальной модели.

## Решение

Необходимо учитывать ковариату - начальный вес, кроме того, нужно проверить, нет ли взаимодействия способа обработки от глистов и начального веса

```{r}
MG1 <- lm(wt ~ treat * init, data = goat)
```

Формула модели со взаимодействием выглядит в сокращенном виде так:

```{r echo=FALSE, results='asis'}
formula(MG1)
```

а в полном виде то же самое выглядит так:

```{r echo=FALSE, results='asis'}
full_fact <- function(fit, nways = 2){
  vars <- all.vars(formula(fit))
  if(nways > length(vars) - 1 | nways <= 0) {
    stop("nways should be a positive number less or equal to the number of predictors")
  } 
  pred <- vars[-1]
  for (i in 2:nways) {
    pred <- c(pred, paste(combn(vars[-1], 1), collapse = ":"))
  }
  frm <- paste(vars[1], paste(pred, collapse = " + "), sep = " ~ ")
  return(frm)
}
cat(full_fact(fit = MG1, nways = 2))
```

## График модели со взаимодействием

Похоже, что взаимодействие не будет достоверным. Если это и вправду так, то этот график нам больше не понадобится.

```{r}
gg_g <- ggplot(data = goat, aes(y = wt, x = init, colour = treat)) + 
  geom_point()  +
  labs(x = "Начальный вес, кг",
       y = "Привес, кг") +
  scale_colour_discrete("Способ обработки", breaks = c("intensive", "standard"), labels = c("Интенсивный", "Стандартный"))
gg_g + geom_smooth(method = "lm")
```

## Проверяем условия применимости

```{r, fig.show='hold', fig.height=3.5, fig.width=10}
op <- par(mfrow = c(1, 3), cex = 1)
qqPlot(MG1)
plot(MG1, which = 3)
plot(MG1, which = 4)
par(op)
```

Все хорошо

## Выбор оптимальной модели

Пробуем удалить взаимодействие

```{r}
drop1(MG1, test = "F")
```

Можно удалять

## Удаляем взаимодействие и пробуем упростить дальше

```{r}
MG2 <- update(MG1, .~. - treat:init)
drop1(MG2, test = "F")
```

Дальше упростить не получится. Вот наша оптимальная модель

## Проверяем условия применимости финальной модели

```{r, fig.show='hold', fig.height=3.5, fig.width=10}
op <- par(mfrow = c(1, 3), cex = 1)
qqPlot(MG2)
plot(MG2, which = 3)
plot(MG2, which = 4)
par(op)
```

Все в порядке

## Проверяем значимость коэффициентов

```{r}
summary(MG2)
```

## Записываем уравнение модели

```{r}
coef(MG2)
```

Уравнение:

```{r echo=FALSE,results='asis'}
lm_equation(MG2, strict = FALSE)
```

Привес коз при интенсивной обработке от глистов на 1.26 кг выше, чем при стандартном методе обработки (t-тест, p < 0.05)

## Данные для графика с параллельными прямыми

Решение средствами пакета `plyr`:
```{r, tidy=FALSE}
# делим датафрейм на части по переменной treat
# по каждой из частей считаем
# последовательность от мин. до макс. значения Yarrow
my_df <- plyr::ddply(goat, .(treat),
    summarise,
    init = seq(min(init),  max(init), length = 10))
# Считаем предсказанные значения и стандартные ошибки
MG2_pred <- predict(MG2, newdata = my_df, se.fit = TRUE)
# Добавляем их в датафрейм
my_df$wt <- MG2_pred$fit
my_df$SE <- MG2_pred$se.fit
```

## Самостоятельно попробуйте разобрать, как сделать тот же самый исходный датафрейм в пакете dplyr

```{r, message=FALSE, eval=FALSE}
library(dplyr)
my_df <- goat %>% 
  group_by(treat) %>%
  summarise(min_init = min(init),
  max_init = max(init)) %>% group_by(treat) %>% 
  do(data.frame(init = seq(.$min_init, .$max_init, length = 10))) %>% 
  ungroup %>% 
  mutate(wt = predict(MG2, newdata = .),
    SE = predict(MG2, newdata = ., se.fit = TRUE)$'se.fit')
```

## Строим график

```{r, tidy=FALSE}
gg_g_parallel <- 
  ggplot(data = my_df, aes(y = wt, x = init, fill = treat, colour = treat)) + 
  geom_line() + 
  geom_ribbon(alpha = 0.3, 
              aes(ymax = wt + 1.98 * SE, 
                  ymin = wt - 1.98 * SE), colour = NA) +
  geom_point(data = goat)
gg_g_parallel
```

## Подписываем оси

```{r, tidy=FALSE}
gg_g_parallel + 
  labs(x = "Начальный вес, кг", y = "Привес, кг") +
  scale_colour_discrete("Способ обработки", breaks = c("intensive", "standard"), 
                        labels = c("Интенсивный", "Стандартный")) +
  scale_fill_discrete("Способ обработки", breaks = c("intensive", "standard"), 
                      labels = c("Интенсивный", "Стандартный"))
```


## Take home messages

- Коэффициенты регрессии при дискретных предикторах позволяют сопоставить средние значения для каждого уровня фактора со средним значением для базового уровня.
- При изменении базового уровня, коэффициенты изменятся, но суть модели останется той же.
- В одной модели можно объединить как непрерывные, так и дискретные предикторы.
- При анализе экспериметальных данных, включение в анализ некоторых ковариат может помочь лучше увидеть закономерности.


## Что почитать
+ Quinn G.P., Keough M.J. (2002) Experimental design and data analysis for biologists, `Chapter 12`.
