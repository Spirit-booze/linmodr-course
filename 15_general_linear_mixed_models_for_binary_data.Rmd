---
title       : Смешанные модели для бинарных зависимых величин
subtitle    : Линейные модели, осень 2015
author: Вадим Хайтов, Марина Варфоломеева
presenters: [{
    name: 'Вадим Хайтов',
    company: 'каф. ЗБП, СПбГУ',
    }]
output:
  ioslides_presentation:
    widescreen: true
    css: my_styles.css
    logo: Linmod_logo.png
---

## Вы узнаете

- Об обобщенных смешанных линейных моделях (GLMM) и о функциях R, которые могут их рассчитать

### Вы сможете

- Построить обобщенную смешанную модель для бинарных данных.
- Применить для построения модели функции из нескольких пакетов, реализованных в R.




```{r setup, include = FALSE, cache = FALSE}
#-- RUN THE FRAGMENT BETWEEN LINES BEFORE COMPILING MARKDOWN
# to configure markdown parsing
options(markdown.extensions = c("no_intra_emphasis", "tables", "fenced_code", "autolink", "strikethrough", "lax_spacing", "space_headers", "latex_math"))
#------
# output options
options(width = 70, scipen = 6, digits = 3)

# to render cyrillics in plots use cairo pdf
options(device = function(file, width = 7, height = 7, ...) {
  cairo_pdf(tempfile(), width = width, height = height, ...)
  })
library(knitr)
# chunk default options
opts_chunk$set(fig.align='center', cache=FALSE, tidy = TRUE, fig.width = 7, fig.height = 3, message=FALSE, warning=FALSE)
```



# Вспомним основные идеи работы с бинарными переменными

## Вопросы
>- Какое распределение используют при работе с бинарными данными? 
>- Сколько параметров в функции плотности вероятности этого распределения? 
>- В каком соотношении находятся матожидание и дисперсия этого распределения?

## Биномиальное распределение

$f(y; N, \pi) = \frac{N!}{y! \times (N-y)!} \times \pi^y \times (1 - \pi)^{N-y}$

<div class="columns-2">

<small>

### Два параметра ($N$, $\pi$)

Среднее: &emsp;&emsp; $E(Y)  = N \times \pi$  
Дисперсия: $var(Y) = N \times \pi \times (1-\pi)$  
Параметр $N$ определяет количество объектов в испытании  
Парметр $\pi$ - вероятность события ($y = 1$)

### Пределы варьирования

$0 \le Y \le +\infty$, &emsp; $Y$ **целочисленные**
</small>


```{r, echo=FALSE, fig.width=5, fig.height=5}
library(ggplot2)
mu1 <- 0.1
mu2 <- 0.5
N1 <- 10
N2 <- 30

y <- 0:30
pi <- data.frame(y = rep(y, 4), pi = c(dbinom(y, size = N1, prob = mu1), dbinom(y,  size = N1, prob = mu2), dbinom(y,  size = N2, prob = mu1), dbinom(y,  size = N2, prob = mu2)),  mu = rep(c(mu1, mu2), each = 2*length(y)), N = rep(c(N1, N2, N1, N2), each = length(y)))

ggplot(pi, aes(x = y, y = pi)) + geom_bar(stat = "identity") + facet_grid(N~mu,  scales = "free_y", labeller = label_both) + ggtitle("Биномиальное распрделение \n при разных параметрах") + ylab("Плотность вероятности (f)")

```
</div>

##Вопросы 
>- Что такое шансы?
<br><br>
>- Что такое логиты?
<br><br>
>- Какую связывающую функцию обычно используются при работе с бинарными перменными отклика?

##Шансы и логиты   
Дискретный отклик: 1 или 0    
<br><br>
Вероятност события: $\pi = \frac{N_i}{N_{total}}$   
<br><br>
Шансы (odds): $odds=\frac{\pi}{1-\pi}$   
<br><br>
_Логиты_ (logit):  $ln(odds)=\ln(\frac{\pi}{1-\pi})$   

##Связывающая функция для бинарных перменных отклика

Каноническая связывающая функция - *логит-функция*: $\eta(\pi)=\ln(\frac{\pi}{1-\pi})$

`family = binomial(link = "logit")`

Помимо логит-функции можно применить еще несколько:

*Complementary Log-Log* связывающая функция : $\eta(\pi)=\ln(-\ln(1-\pi))$  
`family = binomial(link = "cloglog")`    

*Пробит* - связывающая фунция: $\eta(\pi)=\Phi^{-1}(\pi)$  
`family = binomial(link = "probit")`


##Что где находится на этом графике?

```{r, echo=FALSE, fig.height=5}
require(ggplot2)
x <- seq(1:50)
dat <- data.frame(y = NA, x = NA)
for(i in 1:length(x)) {d <- data.frame(y = rbinom(8, 1, 0.02*i), x = i)
dat <- rbind(dat, d)}

M <- glm(y ~ x, data = dat, family = "binomial")
dat<-dat[-1,]

dat_fr <- data.frame(x = unique(dat$x), y = tapply(dat$y, dat$x, data = dat, FUN=mean))

ggplot(dat, aes(x = x, y = y)) + geom_smooth(method= "glm", method.args = list(family = "binomial"), color = "red", size = 2) + geom_point(aes(x = x, y = y), position = position_jitter(height = 0.01)) + geom_point(data = dat_fr, aes(x = x, y = y), size = 4, color = "blue")

```

#Построение модели для бинарной переменной отклика
## Морские желуди: Кого съедят бореотрофоны? {.smaller .columns-2}
Данные взяты из работы    
Yakovis Y., Artemieva A. "Bored to Death: Community-Wide Effect of Predation on a Foundation Species in a Low-Disturbance Arctic Subtidal System" PLOS, 2015. DOI: 10.1371/journal.pone.0132973    
  
<img src="images/druse.png" width="400" > 

<img src="images/drilled_barnacle.png" height="550" > 


##Вопрос: от каких факторов зависит будет ли атакован балянус хищником?
Мы будем оценивать связь вероятности гибели балянуса от нападения *Boreotrophon clathratus*.   


###Дизайн сбора материала 

<img align="middle" src="images/design.png" width="600" height="400" > 


##Читаем данные

```{r}
bal <- read.table("data/Yakovis2.csv", header = TRUE, sep = ";")
```

```{r}
#Some housekeeping
bal$Site <- factor(bal$Site)
bal$Sample <- factor(bal$Sample)
bal$Substrate_ID <- factor(bal$Substrate_ID)

```



##Переменные 

`Site` -точка сбора материала    
`Sample` - квдарат 1х1 м, на котором производился сбор друз   
`BorN` - количество *Boreotrophon clathratus* на квадрате   
`Substrate_ID` - Номер друзы   
`ALength` - Диаметр апертуры   
`Age` - Возраст балянуса   
`Position` - Расположение балянуса (первичный субстрат/вторичный субстрат)   
`Status` - живой/мертвый 
<br> <br>
`Drill` - Зависимая переменная (0 - нет следов сверления; 1 - есть следы сверления)

###Для ответа на поставленный вопрос целесообразно работать с мертвыми особями

##Задание

Вычислите какая доля живых и мертвых особей несет следы сверления

##Решение

```{r}
bal1 <- bal[bal$Status == "live_barnacle", ]
mean(bal1$Drill ==1) 

```

```{r}
bal2 <-  bal[bal$Status == "empty_test", ]
mean(bal2$Drill == 1) 
```



## Задание 
###Напишите код, который задаст формулу для фиксированной части модели 

##Решение
```{r}
Fix_effect <- formula(Drill ~ BorN + ALength + Age + Position + Site)
```

## Задание 
###Напишите код, который задаст формулу для случайной части модели 

##Решение

```{r}
Rand_effect <- formula(~1|Sample/Substrate_ID)

```


##Согласно дизайну сбора материала, необходимо построить обобщенную смешанную линейную модель (GLMM)

Функция максимального правдоподобия для GLMM     

$$Lik(\beta, D) = \Pi_i\int f(Y_i|b_i)\times f(b_i)db_i$$

Вычисление максимума функции правдоподобия для GLMM может производиться только в численном виде (аналитическое решение невозможно). Поэтому все алгоритмы очень затратны по времени.  

##Инструменты `R`, позволяющие подобрать GLMM

Пакет         | Функция     | Особенности работы функции   
|-------------|-------------|-------------|  
`MASS` | `glmPQL()` | Использует penalised quasi-likelihood (PQL) алгоритм, следовательно не выдает AIC. Выбор оптмальной модели может производиться только на основе оценок статистической значимсоти параметров (критерий Вальда). Работает быстро.    
`glmmML`  | `glmmML()` | Выдает значение AIC. Может использовать только один уровень группирующих факторов. Работает быстро.   
`lme4` |  `glmer()`  | Выдает значение AIC. Работает медленно. При сложных моделях часто не сходится.    
`glmmADMB`  | `glmmadmb()` | Выдает значение AIC. Работает ОЧЕНЬ медленно (Для сложных моделей и бльших объемов данных до нескольких часов).  


**Важно!**Во всех случаях надо с осторожостью принимать решения при уровнях значимости близкх к 5%!   
Альтернативный подход к построению сложных моделей - использование методов **Байесовской статистики**

##Подбираем модель с помощью функции `glmmPQL`

```{r, eval=FALSE, message=FALSE}
library(MASS)

M1_PQL <- glmmPQL(Fix_effect, random = ~1|Sample/Substrate_ID, data = bal2, family = "binomial")
```


```{r, echo=FALSE, cache=TRUE}
library(MASS)
M1_PQL <- glmmPQL(Fix_effect, random = Rand_effect, data = bal2, family = "binomial", verbose = FALSE)
# Коэффициенты
C_glmmPQL <- round(nlme::fixed.effects(M1_PQL), 3)
```

##Результаты {.smaller}
```{r}
summary(M1_PQL)

```

##Подбираем модель с помощью функции `glmmML()`

```{r, message=FALSE, cache=TRUE}
library(glmmML)
M1_ML <- glmmML(Fix_effect, cluster = Substrate_ID, data = bal2)
M2_ML <- glmmML(Fix_effect, cluster = Sample, data = bal2)
# Коэффициенты
C_glmmML_1 <- round(as.numeric(coefficients(M1_ML)), 3)
C_glmmML_2 <- round(as.numeric(coefficients(M2_ML)), 3)

```

##Результаты первой модели

```{r}
glmmML::summary.glmmML(M1_ML)
```

##Результаты второй модели

```{r}
glmmML::summary.glmmML(M2_ML)
```


##Подбираем модель с помощью функции `glmer()`


```{r, message=FALSE, cache=TRUE}
library(lme4)
M1_glmer <- glmer(Drill ~ BorN + ALength + Age + Position + Site +  (1|Sample/Substrate_ID), data = bal2, family = "binomial") 
C_glmer <- round(lme4::fixef(M1_glmer), 3)
```

##Результаты {.smaller .columns-2}
```{r}
summary(M1_glmer)
```




##Сравним коэффициенты, подобранные разными функциями 

```{r echo=FALSE, eval=FALSE}
data.frame(C_glmmPQL, C_glmmML_1, C_glmmML_2, C_glmer)
```

<pre>
          Parameter glmmPQL glmmML_1  glmmML_2  glmer
1       (Intercept)  -4.119   -4.367   -4.152  -4.404
2              BorN   0.072    0.087*   0.117*  0.094*
3           ALength   0.148*   0.132*   0.065   0.127*
4               Age  -0.100   -0.068    0.036  -0.061
5 Positionsecondary   1.261*   1.297*   1.224*  1.306*
6             Site2  -0.298   -0.290    0.205  -0.231


</pre>

###Выбор на совести исследователя!

##Выбор оптимальной модели

```{r, cache=TRUE}
drop1(M1_glmer)
```

##Выбор оптимальной модели
```{r, cache=TRUE}
M2_glmer <- update(M1_glmer, .~.- Site)
anova(M1_glmer, M2_glmer)
```


##Выбор оптимальной модели

```{r, cache=TRUE}
drop1(M2_glmer)
```

##Выбор оптимальной модели

```{r, cache=TRUE}
M3_glmer <- update(M2_glmer, .~.-Age)
anova(M2_glmer, M3_glmer)
```


##Выбор оптимальной модели

```{r, cache=TRUE}
drop1(M3_glmer)
```

##Результаты {.smaller}

```{r}
summary(M3_glmer)
```

##Проверка валидности модели

```{r, fig.height=5}
plot(M3_glmer)
```


##Проверка валидности модели {.smaller}

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.height=5}
library(ggplot2)
library(gridExtra)
diagnost <- data.frame(.fitted = fitted(M3_glmer), .resid = residuals(M3_glmer, type ="pearson"))

diagnost<-cbind(diagnost, bal2)

Pl1 <- ggplot(diagnost, aes(x = .fitted, y = .resid)) + geom_point() + geom_smooth(se=F)

Pl2 <- ggplot(diagnost, aes(x = BorN, y = .resid)) + geom_point() + geom_smooth(method = "loess", se=F)

Pl3 <- ggplot(diagnost, aes(x = ALength, y = .resid)) + geom_point() + geom_smooth( se=F)

Pl4 <- ggplot(diagnost, aes(x = Position, y = .resid)) + geom_boxplot()

grid.arrange(Pl1, Pl2, Pl3, Pl4, ncol = 2)


```


##Визуализация предсказаний модели {.smaller}

```{r, echo=FALSE, fig.height=5}
MyData <- expand.grid(BorN = seq(min(bal2$BorN), max(bal2$BorN)),
                      ALength = seq(min(bal2$ALength), max(bal2$ALength)),
                      Position = levels(bal2$Position)) 
                      

MyData$Predicted <- predict(M3_glmer,newdata = MyData, type = "response", re.form = NA)

ggplot(MyData, aes(x = ALength, y = Predicted, color = BorN)) + geom_line(aes(group = BorN), size = 1.5) + facet_grid(~Position, labeller = label_both) + scale_color_gradient(low = "green", high = "red")

```

## Summary

- Построение обобщенных смешанных моделей (GLMM) для бинарных перменных отклика аналогично построению моделей для GLM и LMM.
- Идеального алгоритма для построения GLMM пока нет.
- Существующие ныне алгоритмы пригодны только для простых моделей.    


## Что почитать
+ Zuur, A.F. et al. 2009. Mixed effects models and extensions in ecology with R. - Statistics for biology and health. Springer, New York, NY. 





